// ./core/sim_iteration.m
```m
%-----------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  sim_iteration
% 
% Purpose:  one iteration of HRAP simulation
%
%-----------------------------------------------------------------------------

function [s,x,o,t] = sim_iteration(s,x,o,t,i)

dt = s.dt;

t = t + dt;

    [x] = tank(s,o,x,t);
    
    [x] = s.regression_model(s,x);
    
	[x] = comb(s,x,t);
    
	[x] = chamber(s,x);              
    
    [x] = nozzle(s,x);
    
    if s.mp_calc == 1
        mp              = mass(s,x);
        o.m_t(i)        = mp(1);
        o.cg(i)         = mp(2);
    end

    o.t(i)              = t;
    o.m_o(i)            = x.m_o;
    o.P_tnk(i)          = x.P_tnk;
    o.P_cmbr(i)         = x.P_cmbr;
    o.mdot_o(i)         = x.mdot_o;
    o.mdot_f(i)         = x.mdot_f;
    o.OF(i)             = x.OF;
    o.grn_ID(i)         = x.grn_ID;
    o.mdot_n(i)         = x.mdot_n;
    o.rdot(i)           = x.rdot;
    o.m_f(i)            = x.m_f;
    o.dP(i)             = x.dP;
    o.F_thr(i)          = x.F_thr;

end```

// ./core/sim_loop.m
```m
%-----------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  sim_loop
% 
% Purpose:  run HRAP Simulation Environment to predict the performance of a
%           hybrid rocket motor
%
%-----------------------------------------------------------------------------

function [s,x,o,t] = sim_loop(s,x,o,t)

i = 1;
dt = s.dt;

    while true

        t = (i-1)*dt;
        i = i+1;

        [s,x,o,t] = sim_iteration(s,x,o,t,i);

        if x.grn_ID >= s.grn_OD
            o.sim_end_cond = 'Fuel Depleted';
            break
        elseif x.m_o <= 0
            o.sim_end_cond = 'Oxidizer Depleted';
            break
        elseif t >= s.tmax
            o.sim_end_cond = 'Max Simulation Time Reached';
            break
        elseif x.P_cmbr <= s.Pa
            o.sim_end_cond = 'Burn Complete';
            break
        end

    end
    
    o.t                 = o.t(1:sum(o.t>0)+1);
    o.m_o               = o.m_o(1:sum(o.t>0)+1);
    o.P_tnk             = o.P_tnk(1:sum(o.t>0)+1);
    o.P_cmbr            = o.P_cmbr(1:sum(o.t>0)+1);
    o.mdot_o            = o.mdot_o(1:sum(o.t>0)+1);
    o.mdot_f            = o.mdot_f(1:sum(o.t>0)+1);
    o.OF                = o.OF(1:sum(o.t>0)+1);
    o.grn_ID            = o.grn_ID(1:sum(o.t>0)+1);
    o.mdot_n            = o.mdot_n(1:sum(o.t>0)+1);
    o.rdot              = o.rdot(1:sum(o.t>0)+1);
    o.m_f               = o.m_f(1:sum(o.t>0)+1);
    o.F_thr             = o.F_thr(1:sum(o.t>0)+1);
    o.dP                = o.dP(1:sum(o.t>0)+1);

    if s.mp_calc == 1
        o.m_t           = o.m_t(1:sum(o.t>0)+1);
        o.cg            = o.cg(1:sum(o.t>0)+1);
    end

end
```

// ./HRAP/for_redistribution_files_only/propellant_configs/propellant_template.m
```m
%--------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  propellant_template
% 
% Purpose:  Use this script to generate new propellant configurations for
%           HRAP. Change the propellant name in the last line.
%
%--------------------------------------------------------------------------

%Input 1xm array of chamber pressure values in pascals
s.prop_Pc = 500000:500000:5000000;

%Input nx1 array of OF ratio values
s.prop_OF = [1.5:0.5:10]';

%input nxm array for specific heat ratio where n is the length of OF and m is the length of Pc
s.prop_k = [1.2039	1.2041	1.2042	1.2043	1.2043	1.2044	1.2044	1.2044	1.2044	1.2045
1.222	1.2236	1.2244	1.2249	1.2252	1.2254	1.2256	1.2258	1.2259	1.2261
1.2351	1.2364	1.2373	1.2379	1.2384	1.2388	1.2391	1.2394	1.2396	1.2398
1.2494	1.2494	1.2496	1.2498	1.2501	1.2503	1.2505	1.2507	1.2509	1.2511
1.2571	1.2614	1.2636	1.265	1.2661	1.2669	1.2675	1.268	1.2685	1.2689
1.2098	1.2198	1.2254	1.2292	1.232	1.2342	1.2359	1.2374	1.2386	1.2396
1.1773	1.1832	1.1871	1.1901	1.1925	1.1945	1.1963	1.1978	1.1992	1.2005
1.1679	1.1711	1.1731	1.1747	1.1759	1.177	1.1779	1.1788	1.1795	1.1802
1.1648	1.1672	1.1686	1.1697	1.1706	1.1713	1.1719	1.1724	1.1729	1.1733
1.1632	1.1654	1.1667	1.1676	1.1684	1.169	1.1695	1.1699	1.1703	1.1707
1.1621	1.1643	1.1655	1.1664	1.1671	1.1677	1.1682	1.1686	1.1689	1.1693
1.1612	1.1633	1.1646	1.1655	1.1662	1.1668	1.1673	1.1677	1.1681	1.1684
1.1604	1.1627	1.164	1.1649	1.1657	1.1663	1.1668	1.1672	1.1676	1.168
1.1599	1.1622	1.1636	1.1646	1.1654	1.166	1.1666	1.167	1.1675	1.1679
1.1596	1.162	1.1635	1.1646	1.1654	1.1661	1.1667	1.1672	1.1677	1.1681
1.1595	1.1621	1.1637	1.1649	1.1658	1.1666	1.1672	1.1678	1.1683	1.1688
1.1597	1.1625	1.1643	1.1656	1.1666	1.1674	1.1681	1.1688	1.1693	1.1699
1.1601	1.1632	1.1652	1.1666	1.1677	1.1686	1.1694	1.1701	1.1707	1.1713];

%input nxm array for gas molecular mass in g/mol where n is the length of OF and m is the length of Pc
s.prop_M = [32.689	32.717	32.7355	32.7498	32.7618	32.7723	32.7817	32.7903	32.7984	32.806
30.1827	30.202	30.2139	30.2228	30.23	30.2361	30.2415	30.2463	30.2506	30.2546
28.6117	28.631	28.6423	28.6504	28.6568	28.6621	28.6666	28.6705	28.6741	28.6773
27.5403	27.5569	27.5672	27.5747	27.5806	27.5855	27.5897	27.5933	27.5966	27.5995
27.8852	27.9119	27.9261	27.9358	27.9429	27.9486	27.9534	27.9574	27.9609	27.9639
28.7465	28.8043	28.8331	28.8514	28.8646	28.8746	28.8827	28.8894	28.8951	28.9001
29.3015	29.4107	29.4701	29.51	29.5396	29.5628	29.5817	29.5976	29.6112	29.6231
29.653	29.7917	29.8709	29.9261	29.9682	30.0021	30.0303	30.0544	30.0755	30.0941
29.8999	30.0527	30.1418	30.2046	30.2532	30.2926	30.3258	30.3544	30.3795	30.4019
30.0847	30.2438	30.3372	30.4035	30.455	30.497	30.5324	30.5631	30.5901	30.6142
30.2277	30.3886	30.4834	30.5508	30.6032	30.646	30.6822	30.7136	30.7412	30.766
30.3402	30.5003	30.5946	30.6617	30.7138	30.7564	30.7924	30.8236	30.8512	30.8758
30.4295	30.587	30.6796	30.7454	30.7964	30.8381	30.8734	30.9039	30.9308	30.9548
30.5005	30.6541	30.7441	30.808	30.8575	30.8979	30.9319	30.9614	30.9873	31.0105
30.5566	30.7055	30.7924	30.8539	30.9015	30.9402	30.9728	31.001	31.0257	31.0478
30.6006	30.7441	30.8275	30.8864	30.9317	30.9685	30.9995	31.0262	31.0497	31.0705
30.6345	30.7721	30.8518	30.9077	30.9507	30.9855	31.0147	31.0398	31.0619	31.0815
30.6598	30.7914	30.867	30.9199	30.9604	30.9931	31.0205	31.044	31.0646	31.0828];

%input nxm array for adiabatic flame temperature where n is the length of OF and m is the length of Pc in Kelvin
s.prop_T = [1756.2157	1759.4132	1761.4457	1762.9806	1764.2387	1765.3209	1766.2821	1767.1551	1767.9613	1768.715
2030.5337	2034.441	2036.6391	2038.1835	2039.3821	2040.3664	2041.2049	2041.9378	2042.5905	2043.1804
2232.0462	2237.606	2240.6828	2242.7854	2244.373	2245.6445	2246.7032	2247.6096	2248.4017	2249.1052
2389.6848	2395.3548	2398.7063	2401.0775	2402.9039	2404.3841	2405.6253	2406.692	2407.626	2408.4558
2710.3704	2721.1002	2726.6325	2730.2584	2732.9111	2734.9803	2736.6636	2738.0747	2739.2842	2740.339
2970.429	2997.4316	3010.7987	3019.2648	3025.2881	3029.8793	3033.543	3036.5643	3039.1178	3041.3179
3083.4891	3133.3644	3160.6065	3178.9371	3192.5386	3203.2314	3211.9667	3219.3018	3225.5901	3231.0689
3118.2796	3179.4335	3214.4142	3238.7742	3257.3635	3272.3315	3284.8188	3295.5031	3304.8194	3313.0634
3122.6692	3188.2779	3226.4391	3253.3533	3274.1103	3290.9786	3305.168	3317.4003	3328.1406	3337.7064
3113.753	3180.69	3219.8661	3247.6265	3269.1206	3286.648	3301.4374	3314.2229	3325.4781	3335.5269
3098.224	3164.9094	3204.0048	3231.7447	3253.2471	3270.7986	3285.6217	3298.4468	3309.7456	3319.8404
3079.1222	3144.6698	3183.0727	3210.3096	3231.4153	3248.6387	3263.1814	3275.7617	3286.843	3296.7422
3057.9924	3121.8643	3159.2057	3185.6498	3206.1165	3222.8015	3236.8772	3249.0438	3259.7532	3269.3137
3035.6863	3097.5378	3133.5829	3159.051	3178.7263	3194.7414	3208.2337	3219.8819	3230.1237	3239.2576
3012.7033	3072.3059	3106.901	3131.2743	3150.0603	3165.3215	3178.1566	3189.2205	3198.9349	3207.5874
2989.3507	3046.5513	3079.5955	3102.7973	3120.6317	3135.0865	3147.2189	3157.6582	3166.8092	3174.9477
2965.826	3020.5239	3051.9533	3073.9366	3090.7825	3104.4006	3115.8047	3125.5974	3134.1659	3141.7733
2942.2612	2994.3943	3024.1726	3044.9129	3060.7525	3073.5204	3084.1859	3093.3239	3101.3035	3108.375];

%name the propellant
s.prop_nm = 'Asphalt';

%Input regression coefficients as [a,n,m], if neglecting m, set m to zero, proper units for G, L and rdot are kg/m^2/s, m, and mm/s
s.prop_Reg = [0, 0, 0];

%input propellant grain density in kg/m^3
s.prop_Rho = 1050;

%type in optimum OF ratio here
s.opt_OF = 6.361;

save('Asphalt.mat')```

// ./propellant_configs/propellant_template.m
```m
%--------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  propellant_template
% 
% Purpose:  Use this script to generate new propellant configurations for
%           HRAP. Change the propellant name in the last line.
%
%--------------------------------------------------------------------------

%Input 1xm array of chamber pressure values in pascals
s.prop_Pc = 500000:500000:5000000;

%Input nx1 array of OF ratio values
s.prop_OF = [1.5:0.5:10]';

%input nxm array for specific heat ratio where n is the length of OF and m is the length of Pc
s.prop_k = [1.2039	1.2041	1.2042	1.2043	1.2043	1.2044	1.2044	1.2044	1.2044	1.2045
1.222	1.2236	1.2244	1.2249	1.2252	1.2254	1.2256	1.2258	1.2259	1.2261
1.2351	1.2364	1.2373	1.2379	1.2384	1.2388	1.2391	1.2394	1.2396	1.2398
1.2494	1.2494	1.2496	1.2498	1.2501	1.2503	1.2505	1.2507	1.2509	1.2511
1.2571	1.2614	1.2636	1.265	1.2661	1.2669	1.2675	1.268	1.2685	1.2689
1.2098	1.2198	1.2254	1.2292	1.232	1.2342	1.2359	1.2374	1.2386	1.2396
1.1773	1.1832	1.1871	1.1901	1.1925	1.1945	1.1963	1.1978	1.1992	1.2005
1.1679	1.1711	1.1731	1.1747	1.1759	1.177	1.1779	1.1788	1.1795	1.1802
1.1648	1.1672	1.1686	1.1697	1.1706	1.1713	1.1719	1.1724	1.1729	1.1733
1.1632	1.1654	1.1667	1.1676	1.1684	1.169	1.1695	1.1699	1.1703	1.1707
1.1621	1.1643	1.1655	1.1664	1.1671	1.1677	1.1682	1.1686	1.1689	1.1693
1.1612	1.1633	1.1646	1.1655	1.1662	1.1668	1.1673	1.1677	1.1681	1.1684
1.1604	1.1627	1.164	1.1649	1.1657	1.1663	1.1668	1.1672	1.1676	1.168
1.1599	1.1622	1.1636	1.1646	1.1654	1.166	1.1666	1.167	1.1675	1.1679
1.1596	1.162	1.1635	1.1646	1.1654	1.1661	1.1667	1.1672	1.1677	1.1681
1.1595	1.1621	1.1637	1.1649	1.1658	1.1666	1.1672	1.1678	1.1683	1.1688
1.1597	1.1625	1.1643	1.1656	1.1666	1.1674	1.1681	1.1688	1.1693	1.1699
1.1601	1.1632	1.1652	1.1666	1.1677	1.1686	1.1694	1.1701	1.1707	1.1713];

%input nxm array for gas molecular mass in g/mol where n is the length of OF and m is the length of Pc
s.prop_M = [32.689	32.717	32.7355	32.7498	32.7618	32.7723	32.7817	32.7903	32.7984	32.806
30.1827	30.202	30.2139	30.2228	30.23	30.2361	30.2415	30.2463	30.2506	30.2546
28.6117	28.631	28.6423	28.6504	28.6568	28.6621	28.6666	28.6705	28.6741	28.6773
27.5403	27.5569	27.5672	27.5747	27.5806	27.5855	27.5897	27.5933	27.5966	27.5995
27.8852	27.9119	27.9261	27.9358	27.9429	27.9486	27.9534	27.9574	27.9609	27.9639
28.7465	28.8043	28.8331	28.8514	28.8646	28.8746	28.8827	28.8894	28.8951	28.9001
29.3015	29.4107	29.4701	29.51	29.5396	29.5628	29.5817	29.5976	29.6112	29.6231
29.653	29.7917	29.8709	29.9261	29.9682	30.0021	30.0303	30.0544	30.0755	30.0941
29.8999	30.0527	30.1418	30.2046	30.2532	30.2926	30.3258	30.3544	30.3795	30.4019
30.0847	30.2438	30.3372	30.4035	30.455	30.497	30.5324	30.5631	30.5901	30.6142
30.2277	30.3886	30.4834	30.5508	30.6032	30.646	30.6822	30.7136	30.7412	30.766
30.3402	30.5003	30.5946	30.6617	30.7138	30.7564	30.7924	30.8236	30.8512	30.8758
30.4295	30.587	30.6796	30.7454	30.7964	30.8381	30.8734	30.9039	30.9308	30.9548
30.5005	30.6541	30.7441	30.808	30.8575	30.8979	30.9319	30.9614	30.9873	31.0105
30.5566	30.7055	30.7924	30.8539	30.9015	30.9402	30.9728	31.001	31.0257	31.0478
30.6006	30.7441	30.8275	30.8864	30.9317	30.9685	30.9995	31.0262	31.0497	31.0705
30.6345	30.7721	30.8518	30.9077	30.9507	30.9855	31.0147	31.0398	31.0619	31.0815
30.6598	30.7914	30.867	30.9199	30.9604	30.9931	31.0205	31.044	31.0646	31.0828];

%input nxm array for adiabatic flame temperature where n is the length of OF and m is the length of Pc in Kelvin
s.prop_T = [1756.2157	1759.4132	1761.4457	1762.9806	1764.2387	1765.3209	1766.2821	1767.1551	1767.9613	1768.715
2030.5337	2034.441	2036.6391	2038.1835	2039.3821	2040.3664	2041.2049	2041.9378	2042.5905	2043.1804
2232.0462	2237.606	2240.6828	2242.7854	2244.373	2245.6445	2246.7032	2247.6096	2248.4017	2249.1052
2389.6848	2395.3548	2398.7063	2401.0775	2402.9039	2404.3841	2405.6253	2406.692	2407.626	2408.4558
2710.3704	2721.1002	2726.6325	2730.2584	2732.9111	2734.9803	2736.6636	2738.0747	2739.2842	2740.339
2970.429	2997.4316	3010.7987	3019.2648	3025.2881	3029.8793	3033.543	3036.5643	3039.1178	3041.3179
3083.4891	3133.3644	3160.6065	3178.9371	3192.5386	3203.2314	3211.9667	3219.3018	3225.5901	3231.0689
3118.2796	3179.4335	3214.4142	3238.7742	3257.3635	3272.3315	3284.8188	3295.5031	3304.8194	3313.0634
3122.6692	3188.2779	3226.4391	3253.3533	3274.1103	3290.9786	3305.168	3317.4003	3328.1406	3337.7064
3113.753	3180.69	3219.8661	3247.6265	3269.1206	3286.648	3301.4374	3314.2229	3325.4781	3335.5269
3098.224	3164.9094	3204.0048	3231.7447	3253.2471	3270.7986	3285.6217	3298.4468	3309.7456	3319.8404
3079.1222	3144.6698	3183.0727	3210.3096	3231.4153	3248.6387	3263.1814	3275.7617	3286.843	3296.7422
3057.9924	3121.8643	3159.2057	3185.6498	3206.1165	3222.8015	3236.8772	3249.0438	3259.7532	3269.3137
3035.6863	3097.5378	3133.5829	3159.051	3178.7263	3194.7414	3208.2337	3219.8819	3230.1237	3239.2576
3012.7033	3072.3059	3106.901	3131.2743	3150.0603	3165.3215	3178.1566	3189.2205	3198.9349	3207.5874
2989.3507	3046.5513	3079.5955	3102.7973	3120.6317	3135.0865	3147.2189	3157.6582	3166.8092	3174.9477
2965.826	3020.5239	3051.9533	3073.9366	3090.7825	3104.4006	3115.8047	3125.5974	3134.1659	3141.7733
2942.2612	2994.3943	3024.1726	3044.9129	3060.7525	3073.5204	3084.1859	3093.3239	3101.3035	3108.375];

%name the propellant
s.prop_nm = 'Asphalt';

%Input regression coefficients as [a,n,m], if neglecting m, set m to zero, proper units for G, L and rdot are kg/m^2/s, m, and mm/s
s.prop_Reg = [0, 0, 0];

%input propellant grain density in kg/m^3
s.prop_Rho = 1050;

%type in optimum OF ratio here
s.opt_OF = 6.361;

save('Asphalt.mat')```

// ./util/chamber.m
```m
%-----------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  chamber
% 
% Purpose:  calculate chamber pressure for current timestep
%
%-----------------------------------------------------------------------------

function [x] = chamber(s,x)

dt = s.dt;

    if s.cmbr_V == 0
        V = 0.25*pi*x.grn_ID^2*s.grn_L;
    else
        V = s.cmbr_V - 0.25*pi*(s.grn_OD^2 - x.grn_ID^2)*s.grn_L;
    end
    
    dV = 0.25*pi*(x.grn_ID^2-x.grn_ID_old^2)*s.grn_L/dt;

    x.mdot_n = x.P_cmbr*s.noz_Cd*0.25*pi*s.noz_thrt^2/x.cstar;

    dm_g = x.mdot_f + x.mdot_o - x.mdot_n;
    
    if x.mdot_o == 0
        x.dm_g = -x.mdot_n;
    end

    x.m_g = x.m_g + dm_g*dt;

    dP = x.P_cmbr*(dm_g/x.m_g - dV/V);

    x.P_cmbr = x.P_cmbr + dP.*dt;

    if x.P_cmbr <= s.Pa
        x.P_cmbr = s.Pa;
        x.mdot_n = 0;
    end
end```

// ./util/comb.m
```m
%--------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  comb
% 
% Purpose:  interpolate gas properties at current chamber pressure and
%           OF ratio
%
%--------------------------------------------------------------------------

function [x] = comb(s,x,t)

    if t <= s.tburn || s.tburn == 0
        x.k     = interp2x(s.prop_OF,s.prop_Pc,s.prop_k,x.OF,x.P_cmbr);
        x.M     = interp2x(s.prop_OF,s.prop_Pc,s.prop_M,x.OF,x.P_cmbr);
        x.T     = interp2x(s.prop_OF,s.prop_Pc,s.prop_T,x.OF,x.P_cmbr);
        x.R = 8314.5/x.M;
        x.rho = x.P_cmbr/(x.R*x.T);
        x.cstar = s.cstar_eff*sqrt((x.R*x.T)/(x.k*(2/(x.k+1))^((x.k+1)/(x.k-1))));
    end
```

// ./util/const_OF.m
```m
%-----------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  const_OF
% 
% Purpose:  model regression of fuel grain at a given value of OF
%
%-----------------------------------------------------------------------------

function [x] = const_OF(s,x)

dt = s.dt;

    x.mdot_f        = x.mdot_o/s.const_OF;
    x.rdot          = x.mdot_f/(s.prop_Rho*pi* ...
                      x.grn_ID*s.grn_L);

    x.grn_ID_old    = x.grn_ID;
    x.grn_ID        = x.grn_ID+2*x.rdot*dt;
    x.m_f           = x.m_f - x.mdot_f*dt;
```

// ./util/impulse.m
```m
%-----------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  impulse
% 
% Purpose:  identify impulse class of motor based on total delvered impulse
%
%-----------------------------------------------------------------------------

function [motorClass,percent] = impulse(totalImpulse)

    if totalImpulse <= 1.25
        motorClass = 'A';
        percent = 100.*(totalImpulse - 0)./(1.25);
    elseif totalImpulse > 1.25 && totalImpulse <= 5
        motorClass = 'B';
        percent = 100.*(totalImpulse - 1.25)./(2.5);
    elseif totalImpulse > 5 && totalImpulse <= 10
        motorClass = 'C';
        percent = 100.*(totalImpulse - 5)./(5);
    elseif totalImpulse > 10 && totalImpulse <= 20
        motorClass = 'D';
        percent = 100.*(totalImpulse - 10)./(10);
    elseif totalImpulse > 20 && totalImpulse <= 40
        motorClass = 'E';
        percent = 100.*(totalImpulse - 20)./(20);
    elseif totalImpulse > 40 && totalImpulse <= 80
        motorClass = 'F';
        percent = 100.*(totalImpulse - 40)./(40);
    elseif totalImpulse > 80 && totalImpulse <= 160
        motorClass = 'G';
        percent = 100.*(totalImpulse - 80)./(80);
    elseif totalImpulse > 160 && totalImpulse <= 320
        motorClass = 'H';
        percent = 100.*(totalImpulse - 160)./(160);
    elseif totalImpulse > 320 && totalImpulse <= 640
        motorClass = 'I';
        percent = 100.*(totalImpulse - 320)./(320);
    elseif totalImpulse > 640 && totalImpulse <= 1280
        motorClass = 'J';
        percent = 100.*(totalImpulse - 640)./(640);
    elseif totalImpulse > 1280 && totalImpulse <= 2560
        motorClass = 'K';
        percent = 100.*(totalImpulse - 1280)./(1280);
    elseif totalImpulse > 2560 && totalImpulse <= 5120
        motorClass = 'L';
        percent = 100.*(totalImpulse - 2560)./(2560);
    elseif totalImpulse > 5120 && totalImpulse <= 10240
        motorClass = 'M';
        percent = 100.*(totalImpulse - 5120)./(5120);
    elseif totalImpulse > 10240 && totalImpulse <= 20480
        motorClass = 'N';
        percent = 100.*(totalImpulse - 10240)./(10240);
    elseif totalImpulse > 20480 && totalImpulse <= 40960
        motorClass = 'O';
        percent = 100.*(totalImpulse - 20480)./(20480);
    elseif totalImpulse > 40960 && totalImpulse <= 81920
        motorClass = 'P';
        percent = 100.*(totalImpulse - 40960)./(40960);
    elseif totalImpulse > 81920 && totalImpulse <= 163840
        motorClass = 'Q';
        percent = 100.*(totalImpulse - 81920)./(81920);
    elseif totalImpulse > 163840 && totalImpulse <= 327680
        motorClass = 'R';
        percent = 100.*(totalImpulse - 163840)./(163840);
    elseif totalImpulse > 327680 && totalImpulse <= 655369
        motorClass = 'S';
        percent = 100.*(totalImpulse - 327680)./(327680);
    elseif totalImpulse > 655360 && totalImpulse <= 1310720
        motorClass = 'T';
        percent = 100.*(totalImpulse - 655360)./(655360);
    else
        motorClass = NaN;
        percent = NaN;
    end

end

%-----------------------------------------------------------------------------
% END OF PROGRAM
%-----------------------------------------------------------------------------```

// ./util/interp1x.m
```m
%-----------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program: interp1x
% 
% Purpose: high efficiency 1-dimensional linear interpolation for point xi given 1xn arrays X and Y
%          up to 10x faster than MATLAB/Octave's built in interp1 command
%
% Input:   row vectors X and Y of length n, point xi
%
% Output:  linearly interpolated value of yi at point xi
%
% Variables:
%
% X:       row vector of length n
% Y:       row vector of length n
% xi:      desired x value for interpolation
% yi:      desired y value for interpolation
% zi:      interpolated Z value at point (xi,yi)
% k:       indice of X immediately preceeding desired point xi
% yi:      interpolated value of Y at point xi
%
%-----------------------------------------------------------------------------

function [yi] = interp1x(X,Y,xi)

  if xi <= X(1)

    yi = Y(1); % If xi is lower than lowest X value, it defaults to the closest value of X

  elseif xi >= X(length(X))

    yi = Y(length(Y)); % If xi is greater than the highest X value, it defaults to the closest value of X

  else

    [k,k] = histc(xi,X); % finds index of array X immediately preceeding xi

    yi = ((Y(k+1)-Y(k))./(X(k+1)-X(k))).*(xi - X(k)) + Y(k); % interpolated value of y at point xi

  end
 
end```

// ./util/interp2x.m
```m
%--------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  interp2x
% 
% Purpose:  high efficiency 2-dimensional linear interpolation for point
%           (xi,yi) given 1xn array X, mx1 array Y, and mxn array Z
%
% Input:    row vector X of length n of increasing numerical value, column
%           vector Y of length m of increasing numerical value, nxm array
%           Z, and points xi and yi at which to interpolate
%
% Output:   linearly interpolated value of Z at point xi, yi
%
% Note:     for values of xi or yi outside of range of X or Y, interpolation
%           will default to the maximum or minimum value of X or Y
%
% Limits:   X and Y must be monotonically increasing row and column vectors
%
% Variables:
%
% X:        row vector of length n
% Y:        column vector of length m
% Z:        array with dimensions nxm corresponding to X and Y
% xi:       desired x value for interpolation
% yi:       desired y value for interpolation
% zi:       interpolated Z value at point (xi,yi)
% k:        indice of X immediately preceeding desired point xi
% l:        indice of Y immediately preceeding desired point yi
% Z1:       array of Z values for X(k) and all Y values
% zi1:      interpolated value of Z between Y(l) and Y(l+1)
% Z2:       array of Z values for X(k+1) and all Y values
% zi2:      interpolated value of Z between Y(l) and Y(l+1)
% Z3:       interpolated values of Z corresponding to (X(k),yi) and
%           (X(k+1),yi)
% zi:       interpolated value of Z corresponding to (xi,yi)
%
%--------------------------------------------------------------------------

function [zi] = interp2x(X,Y,Z,xi,yi)

  % find nearest indices below xi and yi

    if xi >= X(end)

      k = length(X);

    elseif xi <= X(1)

      k = 1;
      
    else

      [~,k] = histc(xi,X); % finds index of array X immediately preceeding xi
      
    end

    if yi >= Y(end)

      l = length(Y);

    elseif yi <= Y(1)

      l = 1;

    else

      [~,l] = histc(yi,Y); % finds index of array Y immediately preceeding yi

    end

    % isolate lower row of Z for interpolation

    if xi >= X(end)

      Z1 = Z(:,length(X));

    elseif xi <= X(1)

      Z1 = Z(:,1);

    else

      Z1 = Z(:,k);

    end

    if yi >= Y(end)

      zi1 = Z1(l);

    elseif yi <= Y(1)

      zi1 = Z1(1);

    else

      zi1 = ((Z1(l+1)-Z1(l))./(Y(l+1)-Y(l))).*(yi - Y(l)) + Z1(l); % interpolated value of Z1 at yi

    end

    % isolate upper row of Z for interpolation

    if xi >= X(end)

      Z2 = Z(:,length(X));

    elseif xi < X(1)

      Z2 = Z(:,1);

    else

      Z2 = Z(:,k+1);

    end

    % Second interpolation

    if yi >= Y(end)

      zi2 = Z2(l);

    else

      zi2 = ((Z2(l+1)-Z2(l))./(Y(l+1)-Y(l))).*(yi - Y(l)) + Z2(l); % interpolated value of Z2 at yi

    end

    % Third Interpolation

    Z3 = [zi1 zi2]; % upper and lower bounds for zi

    if xi >= X(end)

      zi = Z3(2);

    elseif xi <= X(1)

      zi = Z3(1);

    else 

      zi = ((Z3(2) - Z3(1))./(X(k+1) - X(k))).*(xi - X(k)) + Z3(1); % interpolated value of Z at (xi,yi)

    end

end```

// ./util/mass.m
```m
%--------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  mass
% 
% Purpose:  find center of mass of motor at a given time
%
%--------------------------------------------------------------------------

function [mp] = mass(s,x)

x.m_t       = s.mtr_m + x.m_o + x.m_f;

if x.mLiq_new < 0
    x.mLiq_new = 0;
end

tA          = 0.25*pi*s.tnk_D^2;

if x.mLiq_new > 0

    m_v     = x.m_o - x.mLiq_new;

    vl      = x.mLiq_new/x.ox_props.rho_l;
    vv      = s.tnk_V - vl;

    hl      = vl/tA;
    hv      = vv/tA;

    CoMl    = s.tnk_X - hl./2;
    CoMv    = s.tnk_X - hl - hv./2;
    CoMf    = s.cmbr_X - s.grn_L./2;

    x.cg    = (x.mLiq_new*CoMl + m_v*CoMv + x.m_f*CoMf + s.mtr_m*s.mtr_cg)./(x.m_t);

elseif x.mLiq_new == 0

    m_v     = x.m_o;

    vv      = s.tnk_V;

    hv      = vv./tA;

    CoMv    = s.tnk_X - hv./2;
    CoMf    = s.cmbr_X - s.grn_L./2;

    x.cg    = (m_v*CoMv + x.m_f*CoMf + s.mtr_m*s.mtr_cg)./(x.m_t);

end

mp = [x.m_t, x.cg];```

// ./util/NOX.m
```m
%--------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  NOX
% 
% Purpose:  compilation of curve fits for thermophysical properties of
%           saturated nitrous oxide as a function of temperature
%
%--------------------------------------------------------------------------

function [op] = NOX(T)
%--------------------------------------------------------------------------
% Critical Properties
%--------------------------------------------------------------------------
Pc = 7251000;
Tc = 309.57;
rhoc = 452;
R = 188.91;

%--------------------------------------------------------------------------
% Vapor Pressure
%--------------------------------------------------------------------------
%Applicable Range: -90 to 36 Celsius

a1 = -6.71893;
a2 = 1.35966;
a3 = -1.3779;
a4 = -4.051;
op.Pv = Pc*exp((1/(T/Tc))*(a1*(1-T/Tc) + ...
    a2*(1-(T/Tc))^(3/2) + a3*(1-(T/Tc))^(5/2) + a4*(1-(T/Tc))^5));

%--------------------------------------------------------------------------
% Saturated Nitrous Oxide Density
%--------------------------------------------------------------------------
%Applicable Range: -90 to 36 Celsius

%Liquid Density
b1 = 1.72328;
b2 = -0.83950;
b3 = 0.51060;
b4 = -0.10412;
op.rho_l = rhoc*exp(b1*(1-(T/Tc))^(1/3) + ...
    b2*(1-(T/Tc))^(2/3) + b3*(1-(T/Tc)) + b4*(1-(T/Tc))^(4/3));

%Vapor Density
c1 = -1.00900;
c2 = -6.28792;
c3 = 7.50332;
c4 = -7.90463;
c5 = 0.629427;
op.rho_v = rhoc*exp(c1*((Tc/T)-1)^(1/3) + ...
    c2*((Tc/T)-1)^(2/3) + c3*((Tc/T)-1) + c4*((Tc/T)-1)^(4/3) + ...
    c5*((Tc/T)-1)^(5/3));

%--------------------------------------------------------------------------
% Specific Enthalpy
%--------------------------------------------------------------------------
%Applicable Range: -90 to 35 Celsius

%Liquid Enthalpy
d1 = -200;
d2 = 116.043;
d3 = -917.225;
d4 = 794.779;
d5 = -589.587;

%Vapor Enthalpy
e1 = -200;
e2 = 440.055;
e3 = -459.701;
e4 = 434.081;
e5 = -485.338;

%Latent Heat of Vaporization
op.Hv = (e1-d1) + (e2-d2)*(1-(T/Tc))^(1/3) + (e3-d3)* ...
    (1-(T/Tc))^(2/3) + (e4-d4)*(1-(T/Tc)) + (e5-d5)*(1-(T/Tc))^(4/3);

%--------------------------------------------------------------------------
% Specific Heat Capacity of Saturated Liquid
%--------------------------------------------------------------------------

f1 = 2.49973;
f2 = 0.023454;
f3 = -3.80136;
f4 = 13.0945;
f5 = -14.5180;

%Specific_Heat_Capacity = 
op.Cp = f1*(1 + f2*(1-(T/Tc))^(-1) + f3* ...
    (1-(T/Tc)) + f4*(1-(T/Tc))^2 + f5*(1-(T/Tc))^3);

%--------------------------------------------------------------------------
% Saturated Vapor Compressibility Factor (Tabulated from empirical data)
%--------------------------------------------------------------------------

op.Z = (Pc*exp((1/(T/Tc))*(a1*(1-T/Tc) + ...
    a2*(1-(T/Tc))^(3/2) + a3*(1-(T/Tc))^(5/2) + a4*(1-(T/Tc))^5)))/ ...
    ((rhoc*exp(c1*((Tc/T)-1)^(1/3) + c2*((Tc/T)-1)^(2/3) + c3*((Tc/T)-1)...
    + c4*((Tc/T)-1)^(4/3) + c5*((Tc/T)-1)^(5/3)))*R*T);
end```

// ./util/nozzle.m
```m
%--------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  nozzle
% 
% Purpose:  calculate thrust for any given timestep
%
%--------------------------------------------------------------------------
function [x] = nozzle(s,x)

    if x.P_cmbr > s.Pa

        A_Ratio         = @(M) ((x.k+1)/2)^(-(x.k+1)/...
                          (2*(x.k-1)))*(1+(x.k-1)/2*M^2)^...
                          ((x.k+1)/(2*(x.k-1)))/M-...
                          s.noz_ER;
        M               = fzero(A_Ratio,3);
        Pe              = x.P_cmbr*(1+0.5*(x.k-1)*M^2)^(-x.k/(x.k-1));
        Cf              = sqrt(((2*x.k^2)/(x.k-1))*(2/(x.k+1))^((x.k+1)/...
                          (x.k-1))*(1-(Pe/x.P_cmbr)^((x.k-1)/x.k)))+...
                          ((Pe-s.Pa)*(0.25*pi*s.noz_thrt^2*s.noz_ER))/...
                          (x.P_cmbr*0.25*pi*s.noz_thrt^2);
        x.F_thr         = s.noz_eff*Cf*0.25*pi*s.noz_thrt^2*x.P_cmbr*...
                          s.noz_Cd;
        
        if x.F_thr < 0
            x.F_thr     = 0;
        end

    else
        x.F_thr         = 0;
    end```

// ./util/shift_OF.m
```m
%-----------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  shift_OF
% 
% Purpose:  model regression of fuel grain using exponential regression law
%
%-----------------------------------------------------------------------------

function [x] = shift_OF(s,x)

dt = s.dt;

    A               = 0.25*pi*x.grn_ID^2;
    G               = x.mdot_o/A;
    x.rdot          = 0.001*s.prop_Reg(1)*G^s.prop_Reg(2)*...
                      s.grn_L^s.prop_Reg(3);
    x.mdot_f     = s.prop_Rho*x.rdot*pi*x.grn_ID* ...
                      s.grn_L;
    x.OF            = x.mdot_o/x.mdot_f;
    
    if x.mdot_f == 0
    x.OF            = 0;
    end

    x.grn_ID_old   = x.grn_ID;
    x.grn_ID       = x.grn_ID+2*x.rdot*dt;
    x.m_f          = x.m_f - x.mdot_f*dt;
```

// ./util/tank.m
```m
%--------------------------------------------------------------------------
% HRAP Simulation Environment
%
% R. Nickel / The University of Tennessee - Knoxville - 2022
%
% Program:  tank
% 
% Purpose:  model oxidizer tank emptying in equilibrium
%
%--------------------------------------------------------------------------

function [x] = tank(s,o,x,t)

dt = s.dt;

%Find oxidizer thermophysical properties
    [x.ox_props] = NOX(x.T_tnk);

    x.P_tnk = x.ox_props.Pv;

%Find oxidizer mass flow rate

    dP = x.P_tnk - x.P_cmbr;
    
    Mcc = sqrt(x.ox_props.Z*1.31*188.91*x.T_tnk*(x.P_cmbr/x.P_tnk)^(0.31/1.31));
    Matm = sqrt(x.ox_props.Z*1.31*188.91*x.T_tnk*(s.Pa/x.P_tnk)^(0.31/1.31));
    
    if Mcc >=1
        Mcc = 1;
    end
    
    if Matm >=1
        Matm = 1;
    end

    if dP < 0
        dP = 0;
    end

    if s.tburn == 0 || t <= s.tburn
        if s.vnt_S == 0
            x.mdot_v = 0;
            if x.mLiq_new == 0
                x.mdot_o = (s.inj_CdA*s.inj_N*x.P_tnk/sqrt(x.T_tnk))*sqrt(1.31/(x.ox_props.Z*188.91))*Mcc*(1+(0.31)/2*Mcc^2)^(-2.31/0.62);
            else
                x.mdot_o = s.inj_CdA*s.inj_N*sqrt(2*x.ox_props.rho_l*dP);
            end
            mD = (x.mdot_o+x.mdot_v)*dt;
        elseif s.vnt_S == 1
            x.mdot_v     = (s.vnt_CdA*x.P_tnk/sqrt(x.T_tnk))*sqrt(1.31/(x.ox_props.Z*188.91))*Matm*(1+(0.31)/2*Matm^2)^(-2.31/0.62);
            if x.mLiq_new == 0
                x.mdot_o = (s.inj_CdA*s.inj_N*x.P_tnk/sqrt(x.T_tnk))*sqrt(1.31/(x.ox_props.Z*188.91))*Mcc*(1+(0.31)/2*Mcc^2)^(-2.31/0.62);
            else
                x.mdot_o = s.inj_CdA*s.inj_N*sqrt(2*x.ox_props.rho_l*dP);
            end
            mD = (x.mdot_o+x.mdot_v)*dt;
        elseif s.vnt_S == 2
            x.mdot_v     = (s.vnt_CdA*x.P_tnk/sqrt(x.T_tnk))*sqrt(1.31/(x.ox_props.Z*188.91))*Matm*(1+(0.31)/2*Matm^2)^(-2.31/0.62);
            if x.mLiq_new == 0
                x.mdot_o = (s.inj_CdA*s.inj_N*x.P_tnk/sqrt(x.T_tnk))*sqrt(1.31/(x.ox_props.Z*188.91))*Mcc*(1+(0.31)/2*Mcc^2)^(-2.31/0.62);
            else
                x.mdot_o = s.inj_CdA*s.inj_N*sqrt(2*x.ox_props.rho_l*dP) + x.mdot_v;
            end
            mD = x.mdot_o*dt;
        else
            error('Error: Vent State Undefined');
        end
    elseif s.tburn > 0 && t > s.tburn
        x.mdot_o        = 0;
        mD              = 0;
    end

%Find mass discharged during time step
    m_o_old              = x.m_o;
    x.m_o                = x.m_o - x.mdot_o*dt;

if x.mLiq_new < x.mLiq_old && x.mLiq_new > 0 && x.mdot_o > 0

    %Find mass of liquid nitrous evaporated during time step
        x.mLiq_old = x.mLiq_new - mD;
        [x.ox_props] = NOX(x.T_tnk);
        x.mLiq_new = (s.tnk_V - (x.m_o/x.ox_props.rho_v))/ ...
                    ((1/x.ox_props.rho_l)-(1/x.ox_props.rho_v));
        mv = x.mLiq_old - x.mLiq_new;

    %Find heat removed from liquid
        dT = -mv*x.ox_props.Hv/(x.mLiq_new*x.ox_props.Cp);
        x.T_tnk = x.T_tnk + dT;
        [op] = NOX(x.T_tnk);
        x.dP = op.Pv - x.P_tnk;

elseif x.mLiq_new >= x.mLiq_old && x.mLiq_new > 0 && x.mdot_o > 0
    
    dP_avg = mean(o.dP(1:sum(o.dP<0)));

    P_new = x.P_tnk + dP_avg;

    vp = @(T) 7251000*exp((1/(T/309.57))*...
        (-6.71893*(1-T/309.57) + 1.35966*(1-(T/309.57))^(3/2) + -1.3779*...
        (1-(T/309.57))^(5/2) + -4.051*(1-(T/309.57))^5)) - P_new;

    x.T_tnk = fzero(vp,x.T_tnk);

    x.dP = x.ox_props.Pv - x.P_tnk;

    [x.ox_props] = NOX(x.T_tnk);

    x.mLiq_new = (s.tnk_V - (x.m_o/x.ox_props.rho_v))/ ...
                    ((1/x.ox_props.rho_l)-(1/x.ox_props.rho_v));
    x.mLiq_old = 0;

elseif x.mLiq_new <= 0 && x.mdot_o > 0
    
    if x.mLiq_new ~= 0
        x.mLiq_new = 0;
    end

    %Find Z factor

    Z_old = x.ox_props.Z;

    Zguess = Z_old;
    epsilon = 1;
    
    Ti = x.T_tnk;
    Pi = x.P_tnk;

    while epsilon >= 0.000001

        T_ratio = ((Zguess*x.m_o)/(Z_old*m_o_old))^(0.3);
        x.T_tnk = T_ratio*Ti;
        P_ratio = T_ratio^(1.3/0.3);
        x.P_tnk = P_ratio*Pi;

        [x.ox_props] = NOX(x.T_tnk);

        Z = x.ox_props.Z;
        
        epsilon = abs(Zguess - Z);

        Zguess = (Zguess + Z)/2;

    end
    
end
```

